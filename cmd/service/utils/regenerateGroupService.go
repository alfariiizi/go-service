package utils

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

func RegenerateGroupServiceGo() error {
	serviceRoot := "internal/core/service"
	groupServiceMap := map[string][]string{}

	// 1. Walk all group dirs and collect services
	dirs, err := os.ReadDir(serviceRoot)
	if err != nil {
		return err
	}

	for _, dir := range dirs {
		if !dir.IsDir() {
			continue
		}
		group := dir.Name()
		groupDir := filepath.Join(serviceRoot, group)

		err := filepath.WalkDir(groupDir, func(path string, d os.DirEntry, err error) error {
			if err != nil || d.IsDir() || !strings.HasSuffix(d.Name(), ".go") || d.Name() == "service.go" {
				return nil
			}

			fset := token.NewFileSet()
			node, err := parser.ParseFile(fset, path, nil, 0)
			if err != nil {
				return err
			}

			for _, decl := range node.Decls {
				gen, ok := decl.(*ast.GenDecl)
				if !ok || gen.Tok != token.TYPE {
					continue
				}
				for _, spec := range gen.Specs {
					typeSpec := spec.(*ast.TypeSpec)
					if typeSpec.Name.IsExported() {
						switch typeSpec.Type.(type) {
						case *ast.IndexExpr, *ast.IndexListExpr:
							groupServiceMap[group] = append(groupServiceMap[group], typeSpec.Name.Name)
						}
					}
				}
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// 2. Generate `service.go` for each group
	for group, services := range groupServiceMap {
		structName := strings.Title(group) + "Service"
		var buf bytes.Buffer
		buf.WriteString(fmt.Sprintf("// Package %s_service provides services for the %s group.\n", group, group))
		buf.WriteString("// Code generated by Service Generator. DO NOT EDIT.\n")
		buf.WriteString("// Template: https://github.com/alfariiizi/vandor.\n")
		buf.WriteString(fmt.Sprintf("package %s_service\n\n", group))
		buf.WriteString("import \"go.uber.org/fx\"\n\n")
		buf.WriteString(fmt.Sprintf("type %s struct {\n", structName))
		for _, s := range services {
			buf.WriteString(fmt.Sprintf("\t%s %s\n", s, s))
		}
		buf.WriteString("}\n\n")

		buf.WriteString(fmt.Sprintf("func New%s(\n", structName))
		for _, s := range services {
			param := strings.ToLower(s[:1]) + s[1:]
			buf.WriteString(fmt.Sprintf("\t%s %s,\n", param, s))
		}
		buf.WriteString(fmt.Sprintf(") %s {\n", structName))
		buf.WriteString(fmt.Sprintf("\treturn %s{\n", structName))
		for _, s := range services {
			param := strings.ToLower(s[:1]) + s[1:]
			buf.WriteString(fmt.Sprintf("\t\t%s: %s,\n", s, param))
		}
		buf.WriteString("\t}\n}\n\n")

		// fx.Module
		buf.WriteString(fmt.Sprintf("var Module = fx.Module(\n\t\"%s_service\",\n\tfx.Provide(\n", group))
		for _, s := range services {
			buf.WriteString(fmt.Sprintf("\t\tNew%s,\n", s))
		}
		buf.WriteString(fmt.Sprintf("\t\tNew%s,\n", structName))
		buf.WriteString("\t),\n)\n")

		err := os.WriteFile(filepath.Join(serviceRoot, group, "service.go"), buf.Bytes(), 0644)
		if err != nil {
			return fmt.Errorf("failed to write %s/service.go: %w", group, err)
		}
	}

	return nil
}
